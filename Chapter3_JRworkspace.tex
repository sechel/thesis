\documentclass[Thesis.tex]{subfiles}
\begin{document}
%\setkeys{Gin}{draft=false}
\chapter{Introduction}

In all chapters of Part~\ref{part:implementation}, words printed in {\sc SmallCapitals} are names of software packages; words printed
in {\tt TeleType} are names of {\sc Java} classes, methods, or fields.

\begin{figure}[h]
	\centering
	\includegraphics[width=\linewidth]{figures/software_architecture}
	\caption[Software package dependencies]{
		Software architecture and dependencies of the DDG Framework. 
		{\sc Jtem} library packages (green), application packages (blue). {\sc JReality} is used mainly for 3d-visualization (grey).}
	\label{fig:software_architecture}
\end{figure}

In the field of Discrete Differential Geometry (DDG) there is a special need for experiments
with the help of computer software. Especially if the methods of DDG are applied
to problems in computer graphics, geometry processing, or architecture, algorithms have 
to be implemented and convincing examples have to be presented. Additionally, a suitable 
visualization of the results has to be included in a state-of-the-art publication.

There is a growing knowledge of software development in the mathematical community. This 
is partly due to the curricula of universities, which started to include programming courses for 
undergraduate students with an emphasis on mathematical visualization~\cite{VisMathHomepage, 
CaltechVisMath}. This knowledge enables students to extend their abilities of creating visualizations and 
mathematical software, where former generations of students solely used the visualization 
abilities of standard computer algebra packages like Mathematica or MatLab.

The audience of the following chapters is two-fold. On the one hand it is students creating their 
visualizations of surfaces and develop algorithms. On the other hand it is researchers in the
field of DDG who need a stable data structure and programming
infrastructure to get the job done.

This part of the thesis is the description of a set of software packages
written in the programming language {\sc Java}. They are 
specifically designed for the creation of custom interactive software for experiments with algorithms and geometric objects treated within DDG. 
Its main components {\sc JRworkspace}, {\sc HalfEdge}, and {\sc HalfEdgeTools} are part of the collection of mathematical software libraries {\sc Jtem}~\cite{JtemWebsite}.
They are currently being used for research projects within the geometry group as well as for teaching mathematical visualization courses at TU-Berlin \cite{VisMathHomepage}.
Representing the core of {\sc VaryLab} they are being deployed to users from the field of architectural geometry via the online version {\sc VaryLab}~\cite{varylab-web-page}.

%Section~\ref{sec:related_work} gives an overview of existing software packages that have a focus similar to the DDG Framework. 
Chapter~\ref{chp:jrworkspace} introduces the {\sc JRworkspace} library of the 
{\sc Jtem} project~\cite{JtemWebsite}. It is the foundation of any application created with 
the framework. It is also the user interface basis of {\sc Jreality}, a mathematical 
visualization library that uses {\sc JRworkspace} as plug-in and user interface 
tool~\cite{JrealityWebsite}. Chapter~\ref{chp:halfedge} introduces the 
{\sc HalfEdge} and {\sc HalfEdgeTools} package. They implement a half-edge data 
structure and various user interface tools and algorithms for interaction and editing.  
In Chapter~\ref{chp:conformallab} we describe the software 
{\sc ConformalLab}. This implements the algorithms described in Chapter~\ref{chp:uniformization}.
Chapter~\ref{chp:varylab} introduces {\sc VaryLab}, the software implementation of the 
methods described in Chapters~\ref{chp:periodic_conformal_maps}, \ref{chp:quasiisothermic}, and~\ref{chp:gridshells}.
The chapters about {\sc ConformalLab} and {\sc VaryLab} should enable the reader to use the  software to reproduce the results presented in the respective chapters of this work.

Figure~\ref{fig:software_architecture} visualizes the dependencies of the different software packages.
Every package depends on {\sc JRworkspace} that implements plug-in functionality. 
It is the basis of the {\sc Jreality} plug-in system. 
{\sc Half\-Edge\-Tools} is using {\sc Jreality} for visualization and is build on top of the {\sc Jtem} project {\sc Half\-Edge}. 
{\sc ConformalLab} and {\sc VaryLab} use {\sc Jpetsc/Jtao} to perform numerical
optimization. Their algorithms are implemented as {\sc JRworkspace} plug-ins.

The development of the described software is joint work with Thilo R{\" o}rig 
({\sc HalfEdgeTools, VaryLab}), the {\sc Jreality} members~\cite{JrealityWebsite}, Hannes 
Sommer ({\sc Jpetsc/Jtao})~\cite{jpetsctao-web-page}, Ulrich Pinkall and Paul Peters 
({\sc JRworkspace}), and Boris Springborn ({\sc Halfedge}).

%
%\section{Related Work}
%\label{sec:related_work}
%There are many mathematically oriented software frameworks available to the community. So why adding a new one to the list? The answer lies in the history of the software. 
%JavaView, CGAL, libIGL, ...
%Do I really want to write about this here??
%
%\subsubsection{JavaView} JavaView, see \cite{javaview}, is 3d geometry visualization software. It has a strong focus on web presentation as {\sc Java} applet.
%
%\subsubsection{libigl} C++ 


\chapter{{\sc JRworkspace} - Java API for modular applications}
\label{chp:jrworkspace}

%\begin{figure}
%	\centering
%	\includegraphics[width=0.8\linewidth]{figures/jrworkspace_uml}
%	\caption[{\sc JRworkspace} API]{
%		UML diagram for the {\sc JRworkspace} API.
%	}
%	\label{fig:jrworkspace_uml}
%\end{figure}

{\sc JRworkspace} is part of the {\sc Jtem} family of software projects 
\cite{JtemWebsite}. It defines a simple API to create modular Java applications. This API consists of
three basic classes (Listings~\ref{lst:plugin_base}, \ref{lst:controller_interface}, and 
\ref{lst:plugin_info}).
The project contains a reference implementation that supports the creation of Java
Swing applications using the {\sc JRworkspace} API. This implementation is used in all 
applications described in this work.

\section{Plug-ins and the controller}
\label{sec:plugins}

In a {\sc JRworkspace} application a feature is implemented as plug-in and the corresponding Java class 
extends the abstract class Plugin
(Listing~\ref{lst:plugin_base}). The idea is that a plug-in can be installed by the controller 
calling its {\tt install} method or uninstalled via the {\tt uninstall} method. You can think of it 
as a feature added to your program. In particular there is no more than one instance of a
plug-in class in a {\sc JRworkspace} application.

A plug-in has a life-cycle during the runtime of the program which includes these basic
steps:
\begin{center}
\begin{tabular}{r|r|l}
	instantiation & 1 & set default plug-in state\\
	{\tt restoreStates} & 2 & load plug-in state from {\tt Controller}\\
	{\tt install} & 3 & calls {\tt getPlugin} to obtain dependent plug-ins\\
	{\tt --}  & 4 & program execution\\
	{\tt storeStates} & 5 & stores state values to the {\tt Controller}\\
	({\tt uninstall} & 6 & clean up)
\end{tabular}
\end{center}
Step 1 instantiates a plugin and initializes its default properties. In step 2 the controller 
calls the {\tt restoreStates} method. Step 3 is the actual installation of the plug-in. 
During runtime
of the application the plug-in can interact with possible user interface it created during 
installation or offer services to other plug-ins. 
Before program termination or before uninstall the {\tt storeStates} method is called. The plug-in
is supposed to store its state values by calling the {\tt storeProperty}
method of the controller.
Inter-plug-in-communication is done via the {\tt getPlugin} method of the controller. 
A plug-in should call {\tt getPlugin} from within the {\tt install} method to obtain the unique instance 
of a dependent plug-in. The {\tt getPlugin} method always returns the same instance of a plug-in so its
result can be stored by the {\tt install} method for later reference, see for example 
Listing~\ref{lst:sample_plugin}. Step 6 {\tt uninstall} is only used with dynamic plug-ins that support 
this operation. An implementation of {\tt Controller} may not support uninstallation of plug-ins.

We describe the basic API usage from a programmers point of view by giving an example plug-in
in Listing~\ref{lst:sample_plugin} and the source code of the three basic API classes 
{\tt Plugin}, {\tt Controller}, and {\tt PluginInfo} in Listings~\ref{lst:plugin_base}, 
\ref{lst:controller_interface}, and \ref{lst:plugin_info}.

\lstinputlisting[
	caption={
A simple plug-in class. It depends on a plug-in called {\tt DependentPlugin} 
and has the property {\tt doubleState}. It provides the method {\tt helloPlugin()} that 
prints some message. In the {\tt storeStates} method the value of {\tt doubleState} is
written to the controller. The class {\tt MyPlugin} is used as context class. The name of 
this class is used as name space to avoid property name ambiguities. The value of {\tt doubleState}
is read from the controller in the {\tt restoreStates} method using the same context class and
property name as in {\tt storeStates}. If there is no value with the given context and name
the default value {\tt 1.0} is returned by the {\tt getProperty} method. 
	},
	label=lst:sample_plugin,
	captionpos=b,
	firstline=6
] {java/de/sechel/thesis/MyPlugin.java}

\lstinputlisting[
	caption={
The {\tt Plugin} base class (excerpt). Note that plug-ins are equal if their classes are. 
It is not supported to have multiple instances of the same plug-in class installed.
	},
	label=lst:plugin_base,
	captionpos=b,
	firstline=3,
	lastline=30
] {java/de/jtem/jrworkspace/plugin/Plugin.java}

\lstinputlisting[
	caption={
The {\tt Controller} interface. A plug-in can obtain other plug-in instances by calling 
{\tt getPlugin} which returns a unique instance of the given plug-in class. The semantics
of the {\tt getPlugins} methods is different. It returns all plug-ins that are already known 
to the controller so no new dependencies are created by calling {\tt getPlugins}. Property
handling is done via the {\tt xxProperty} methods. Note that any {\tt Object} can be used
as property value. This requires the controller to use generic serialization to store data. It is 
strongly discouraged to use other classes than official java API classes as stored values as 
deserialization may fail if class geometry changes. 
	},
	label=lst:controller_interface,
	captionpos=b,
	firstline=5
] {java/de/jtem/jrworkspace/plugin/Controller.java}

\lstinputlisting[
	caption={
The plug-in meta data class (excerpt). Instances are returned by the {\tt getPluginInfo}
method of any plug-in. The value of the {\tt name} field is a plaintext name that could be 
shown in a user interface as well are the {\tt vendorName} and {\tt email} information. An optional 
{\tt icon} and a {\tt documentationURL} can be given. The flag {\tt isDynamic} is evaluated
by controller implementations that support deinstallation of plug-ins. A dynamic plug-in can
be installed or uninstalled during application runtime. A non-dynamic plug-in must be installed
at startup and remains installed until program termination. The static {\tt create} method returns
a default {\tt PluginInfo} instance for the given plug-in class.
	},
	label=lst:plugin_info,
	captionpos=b,
	firstline=7,
%	lastline=15
] {java/de/jtem/jrworkspace/plugin/PluginInfo.java}

In the next section we describe an implementation of this API.

\section{Reference implementation}
\label{sec:reference_implementation}
This section describes a reference implementation of the {\sc JRworkspace} plug-in API.
It was started as a user interface framework for {\sc Jreality}~\cite{JrealityWebsite}. It implements
the {\tt Controller} interface in a class called {\tt SimpleController}. This name is historic
and did not change as the features evolved from simple into quite complex.
{\tt SimpleController} implements a {\sc Java Swing\TReg} framework for the creation of complex
modular applications based on the {\sc JRworkspace} API. It defines various plug-in flavors
that define user interface features. The implementation does not support dynamic plug-ins.

In the remainder of this section I describe the basic and most interesting features of this 
implementation. For a complete API reference see the documentation on the {\sc Jtem} website 
\cite{JtemWebsite}.


{\bf Perspective Flavor}

A plug-in implementing the interface {\tt PerspectiveFlavor} provides the base for a program's user 
interface. It implements the method {\tt getCenterComponent} that returns a AWT {\tt Component}
that is placed in the main frame of the application. The main program window itself is created and
managed by the controller.
A reference implementation of this flavor is the {\tt SideContainerPerspective}. It layouts its content 
using a {\tt BorderLayout} and places slots in the north, south, east, and west of the main window. These
slots can contain {\tt ShrinkPanel}s that can be moved between slots by drag-and-drop. A {\tt ShrinkPanel}
behaves like a {\tt JPanel} and has a title bar that resizes the panel when the user clicks with the mouse.

\begin{figure}[H]
\centering
\includegraphics[width=9cm]{jrworkspace/side_containers_hires.pdf}
\caption[The {\tt SideContainerPerspective} user interface plug-in]{The {\tt SideContainerPerspective} implementation uses slots to layout panels at the side of the
main window. The left slot contains three {\tt ShrinkPanel}s, the top and right slots are empty. The menu bar 
and tool bar are created by respective plug-in flavors.}
\label{fig:side_containers}
\end{figure}


{\bf Menu Flavor}

A plug-in implementing the {\tt MenuFlavor} interface provides {\sc Java Swing\TReg} menu 
components that are placed at the top of the main window. A reference implementation of this
flavor is the plug-in {\tt MenuAggregator} that manages menu entries by contexts and
menu paths. Its API provides four methods to add and remove menus, menu items, and
separators. A typical method signature is

\begin{lstlisting}[numbers=none]
	public void addMenu(Class<?> ctx, double priority, JMenu m, String... path)
\end{lstlisting}

where the plug-in stores the menu item with the given context class. This context is used to
bulk-remove menus from a menu aggregator. Menus are sorted ascending
by their priority. The menu item appears at the end of the given menu path. See 
Listing~\ref{lst:menu_aggregator} and Figure~\ref{fig:menu_aggregator}.


\begin{figure}[H]
\centering
\includegraphics[width=7cm]{jrworkspace/menu_bar_hires.pdf}
\caption{The menu created by Listing~\ref{lst:menu_aggregator}}
\label{fig:menu_aggregator}
\end{figure}

\lstinputlisting[
	caption={Usage of the {\tt MenuFlavor} interface and the {\tt MenuAggregator} implementation.},
	label=lst:menu_aggregator,
	captionpos=b,
	firstline=40,
	lastline=51
] {java/de/sechel/thesis/MyMenuBar.java}

{\bf Tool Bar Flavor}

Plug-ins implementing this flavor interface create a {\sc Java Swing\TReg} tool bar at the top of the 
main window. There can be more than one plug-in implementing this interface to create multiple 
tool bars. The API method signatures a similar to the signatures of the menu aggregator flavor. As 
a tool bar does not have a hierarchy, there is no path parameter. The signature of a API method is, e.g.,

\begin{lstlisting}[numbers=none]
	public void addAction(Class<?> context, double priority, Action a).
\end{lstlisting}

The tool bar aggregator implementation can handle {\tt Action}s, {\tt Component}s, and tool bar
separators. See Listing~\ref{lst:tool_bar_aggregator} and Figure~\ref{fig:tool_bar_aggregator}.

\begin{figure}[H]
\centering
\includegraphics[width=7.5cm]{jrworkspace/tool_bar_hires.pdf}
\caption{The tool bar created by Listing~\ref{lst:tool_bar_aggregator}. Elements are sorted according to their
priority.}
\label{fig:tool_bar_aggregator}
\end{figure}

\lstinputlisting[
	caption={Usage of the {\tt ToolFlavor} interface and the {\tt ToolBarAggregator} implementation.},
	label=lst:tool_bar_aggregator,
	captionpos=b,
	firstline=40,
	lastline=50
] {java/de/sechel/thesis/MyToolBar.java}

{\bf The API of {\tt SimpleController}}

A plug-in implementation is independent of the concrete implementation of the {\tt Controller}. To create an
application with the {\tt SimpleController} we need to register plug-ins we want to use and then invoke the
startup sequence. A typical {\tt main} method is, e.g.,

\lstinputlisting[
	caption={{\tt Main} method of a program created with the {\tt SimpleController} implementation. The result
is shown in Figure~\ref{fig:side_containers}.},
	label=lst:main_method,
	captionpos=b,
	firstline=13,
	lastline=28
] {java/de/sechel/thesis/MyApplication.java}

We set the look and feel to be the system look and feel, in this case the Mac OS style. Then we create a
{\tt SimpleController} and set the {\tt magageLookAndFeel} property to {\tt false}. Plug-in properties are saved
to a file called {\tt MyApp.xml}. There are two property modes defined by the {\tt SimpleController}, {\tt StaticPropertiesFile}
and {\tt UserPropertiesFile}. In static mode there is only one file location. In user mode the predefined location can
be altered by the user of the program. This user decision is then stored as a {\sc Java} preference. In this example 
we use the static properties.

\section{{\sc JRworkspace} and {\sc Jreality}}
\label{sec:jrworkspace_jreality}

\begin{figure}
\centering
\includegraphics[width=0.9\textwidth]{jrworkspace/jreality_hires.pdf}
\caption[The {\sc Jreality} user interface.]{The {\sc Jreality} user interface. A {\tt SideContainerPerspective} 
and {\tt ShrinkPanels} is used. The tool bar and 
menu bar is created by the aggregators described in Section~\ref{sec:reference_implementation}. This application
uses a set of predefined user interface features and virtual reality components. In a custom application the developer 
usually registers only a subset of these features.}
\label{fig:jrworkspace_jreality}
\end{figure}

{\sc Jreality} \cite{JrealityWebsite} is a scene graph and visualization library written in {\sc Java}.
The user interface of {\sc Jreality} is based on the {\sc JRworkspace} API and reference
implementation.
A custom {\sc Jreality} application can be based on the central {\tt JRViewer} class. 
This class uses {\tt SimpleController} to manage
plug-in registration and start-up. 
The design of the {\tt JRViewer} application make intensive use of the plug-in concept.
The architecture of the application is divided into separate modules which in turn are realized as plug-ins.
The core functionality is provided by plug-ins implementing the the content, the scene, the view, and the tool system.
Then there are plug-ins providing the tool bar and menu bar as well as the overall layout of shrink panels as described above.


\subfilebibliography
\end{document}

%%% Local Variables:
%%% TeX-master: "Thesis.tex"
%%% End: