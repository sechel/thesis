\documentclass[Thesis.tex]{subfiles}
\begin{document}

\chapter{{\sc ConformalLab} - Conformal maps and uniformization}
\label{chp:conformallab}

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{conformllab/conformallab.png}
\caption{The window of {\sc ConformalLab}.}
\label{fig:conformal_window}
\end{figure}

This chapter enables the reader to reproduce examples contained in this work
that involve uniformization of Riemann surfaces, see
Chapter~\ref{chp:conformal_examples}, and applications of conformal mappings of
Part~\ref{part:applications}. The author has written {\sc Java} software, {\sc
ConformalLab}, to calculate the corresponding data.  The software and the data
is included on the accompanying CD. 

{\sc ConformalLab} is designed to be used via a graphical user interface, see
Figure~\ref{fig:conformal_window}. To store resulting data an XML format is
used. We describe this format in Section~\ref{sec:conformal_data}. The
graphical user interface is described in Section~\ref{sec:conformallab_ui}.
{\sc ConformalLab} uses {\sc JRworkspace}, see Chapter~\ref{chp:jrworkspace},
to implement its user interface. This allows the user interface to be devided
into panels which serve separate purposes.  {\sc ConformalLab} uses {\sc
HalfEdge} and {\sc HalfEdgeTools}, see Chapter~\ref{chp:halfedge}, to work with
discrete surfaces.


\section{XML data format}
\label{sec:conformal_data}
To store and process data {\sc ConformalLab} uses an {\sc XML} data format.
All examples presented in Chapter~\ref{chp:conformal_examples} are stored in
this format.  All XML data is contained in the XML namespace {\tt
http://www.varylab.com/conformallab/types}.


{\bf Schottky data} 

A Riemann surface can be given by Schottky data, see
Section~\ref{sec:schottky_examples}. An example is shown in
Listing~\ref{lst:schottky_xml}. {\tt SchottkyData} can include one or more {\tt
SchottkyGenerator}s. A {\tt SchottkyGenerator} defines fix points $A$ and
$B$, the complex number $\mu$, and a {\tt Circle}. This circle is required to
contain $A$ and must not contain $B$. If there are more that one generator,
then the circles an their images must not intersect.

\begin{lstlisting}[label=lst:schottky_xml, caption={A torus given by schotty data}, 
numbers=none, language=XML, captionpos=b]
<SchottkyData name="Schottky">
	<SchottkyGenerator>
		<A re="-1.0" im="0.0"/>
		<B re="1.0" im="0.0"/>
		<Mu re="0.25" im="0.0"/>
		<Circle radius="1.3">
			<Center re="-1.6" im="0.0"/>
		</Circle>
	</SchottkyGenerator>
</SchottkyData>
\end{lstlisting}

{\bf Hyperelliptic data} 

{\tt HyperEllipticAlgebraicCurve}s as used in the examples of
Section~\ref{sec:examples_elliptic} and \ref{sec:examples_hyperelliptic} are
given by the location of their branch points in the complex plane. All points
must be distinct. Listing~\ref{lst:hyperelliptic_xml} shows the XML
representation of an elliptic algebraic curve defining a Riemann surface of
genus~$1$. The point at infinity cannot be specified and is implicitly given if
an odd number of branch points is listed.

\begin{lstlisting}[label=lst:hyperelliptic_xml, caption={A torus given as 
hyperelliptic data}, numbers=none, language=XML, captionpos=b]
<HyperEllipticAlgebraicCurve name="Curve g2">
	<BranchPoint re="-0.5" im="-1.0"/>
	<BranchPoint re="0.5" im="-1.0"/>
	<BranchPoint re="1.0" im="0.0"/>
	<BranchPoint re="-1.0" im="0.0"/>
</HyperEllipticAlgebraicCurve>
\end{lstlisting}

{\bf Fuchsian data}

A Riemann surface given by Fuchsian data ({\tt UniformizationData}) is
represented by generators of the corresponding Fuchsian group and their inverse
elements as elements of $PSL(2,\mathbb R)$ ({\tt UniformizingGroup} and {\tt
IsometryPSL2R} XML nodes). In addition to the group a fundamental polygon is
defined by its vertices and edges. In Listing~\ref{lst:fuchsian_xml} the
uniformizing group of euclidean motions defines the structure of a flat torus.
The {\tt FundamentalPolygon} is a parallelogram. There is only one {\tt
FundamentalVertex} since all vertices of the parallelogram are indentified.
There are four {\tt FundamentalEdge}s each of which is identified with its
opposite edge of the parallelogram. Each {\tt FundamentalEdge} defines a {\tt
StartPosition} in $\mathbb C$ that is interpreted as an element of $\mathbb R
P^2$. The polygon is positively oriented.

\begin{lstlisting}[label=lst:fuchsian_xml, caption={A torus given by its Fuchsian uniformizing group and a corresponding fundamental polygon. The elements of the group are either euclidean motions or hyperbolic motions given as elements of $PSL(2, \mathbb R)$.}, numbers=none, language=XML, captionpos=b]
<UniformizationData name="Direct Uniformization">
	<UniformizingGroup>
		<IsometryPSL2R 
			m11="1.0" m12="0.0" m13="1.0" 
			m21="0.0" m22="1.0" m23="0.0" 
			m31="0.0" m32="0.0" m33="1.0"
		/>
		<IsometryPSL2R 
			m11="1.0" m12="0.0" m13="0.0" 
			m21="0.0" m22="1.0" m23="1.0" 
			m31="0.0" m32="0.0" m33="1.0"
		/>
		<IsometryPSL2R 
			m11="1.0" m12="0.0" m13="-1.0" 
			m21="0.0" m22="1.0" m23="0.0" 
			m31="0.0" m32="0.0" m33="1.0"
		/>
		<IsometryPSL2R 
			m11="1.0" m12="0.0" m13="0.0" 
			m21="0.0" m22="1.0" m23="-1.0" 
			m31="0.0" m32="0.0" m33="1.0"
		/>
	</UniformizingGroup>
	<FundamentalPolygon>
		<FundamentalVertex index="0"/>
		<FundamentalEdge index="0" nextEdge="1" previousEdge="3" identifiedEdge="2" startVertex="0">
			<StartPosition re="0.0" im="0.0"/>
		</FundamentalEdge>
		<FundamentalEdge index="1" nextEdge="2" previousEdge="0" identifiedEdge="3" startVertex="0">
			<StartPosition re="1.0" im="0.0"/>
		</FundamentalEdge>
		<FundamentalEdge index="2" nextEdge="3" previousEdge="1" identifiedEdge="0" startVertex="0">
			<StartPosition re="1.0" im="1.0"/>
		</FundamentalEdge>
		<FundamentalEdge index="3" nextEdge="0" previousEdge="2" identifiedEdge="1" startVertex="0">
			<StartPosition re="0.0" im="1.0"/>
		</FundamentalEdge>
	</FundamentalPolygon>
</UniformizationData>
\end{lstlisting}

{\bf Discrete data} 

To specify discrete data we use the concept of half edge data structure, see
also Chapter~\ref{chp:halfedge}. Listing~\ref{lst:halfedge_xml} shows the
structure of a {\tt HalfedgeEmbedding}. {\tt Vertices} are assigned coordinates
in $\mathbb RP^3$ and their index. {\tt Halfedge} nodes specify indices of
incident faces, edges, and vertices as defined in Section~\ref{sec:halfedge}.
In addition the data needed to specify the combinatorics of the half edge
datastructure one can specify identifications of vertices and edges. An {\tt
Identification} node contains all vertices that are identified. Consider a
parallelogram fundamental domain of a flat torus. In the parallelogram all four
vertices are identified to form the topological torus. Also the edges of the
parallelogram are identified. An {\tt EdgeIdentification} node defines the four
half edges that belong to the pair of half edges on the torus.

\begin{lstlisting}[label=lst:halfedge_xml, caption={A torus given as {\tt HalfedegeEmbedding}
with identified edge pairs and vertices.}, numbers=none, language=XML, captionpos=b]
<HalfedgeEmbedding name="Uniformizing Map_domain">
	<Vertex x="0.0" y="0.0" z="0.0" w="1.0" index="0"/>
	<Vertex x="1.0" y="0.0" z="0.0" w="1.0" index="1"/>
	<Vertex x="1.0" y="1.0" z="0.0" w="1.0" index="2"/>
	<Vertex x="0.0" y="1.0" z="0.0" w="1.0" index="3"/>
	<Identification>
		<Vertex>0</Vertex>
		<Vertex>1</Vertex>
		<Vertex>2</Vertex>
		<Vertex>3</Vertex>
	</Identification>
	<Halfedge left="0" target="1" next="1" opposite="4" index="0"/>
	<Halfedge left="0" target="2" next="2" opposite="5" index="1"/>
	<Halfedge left="0" target="3" next="3" opposite="6" index="2"/>
	<Halfedge left="0" target="0" next="0" opposite="7" index="3"/>
	<Halfedge left="-1" target="0" next="7" opposite="0" index="4"/>
	<Halfedge left="-1" target="1" next="4" opposite="1" index="5"/>
	<Halfedge left="-1" target="2" next="5" opposite="2" index="6"/>
	<Halfedge left="-1" target="3" next="6" opposite="3" index="7"/>
	<EdgeIdentification edge1="0" edge2="4" edge3="2" edge4="6"/>
	<EdgeIdentification edge1="1" edge2="5" edge3="3" edge4="7"/>
	<Face index="0"/>
</HalfedgeEmbedding>
\end{lstlisting}

The {\tt HalfedgeEmbedding} data type can be used to define disceret maps
between discrete embeddings. A discrete map consists of a domain {\tt
HalfedgeEmbedding} and the correponding image. Both nodes must define the same
number of vertices. The map is defined via vertex indices. A vertex $i$ from
the domain is mapped to the vertex with index $i$ in the image data structure,
see Listing~\ref{lst:halfedgemap_xml}.

\begin{lstlisting}[label=lst:halfedgemap_xml, caption={A discrete map is given by a pair of {\tt HalfedgeEmbedding}s, the {\tt Domain} and {\tt Image} of the map. Both are of type {\tt HalfedgeEmbedding}.}, numbers=none, language=XML, captionpos=b]
<HalfedgeMap name="Uniformizing Map">
	<Domain name="Uniformizing Map_domain">
		...
	</Domain>
	<Image name="Uniformizing Map_image">
		...
	</Image>
</HalfedgeMap>
\end{lstlisting}

A way of defining a discrete Riemann surface is to specify its discrete metric.
A {\tt DiscreteMetric} defines non-oriented {\tt MetricEdges} and their
lengths. {\tt MetricTriangles} are glues along those edges. All triangles are
oriented by the order of edges defined by attributes {\tt edge1}, {\tt edge2},
and {\tt edge3} respectively. By that we can ony encode oriented discrete
Riemann surfaces using a {\tt DiscreteMetric}.  A simple example featurering a
Wente torus is shows in Listing~\ref{lst:discretemetric_xml}.

\begin{lstlisting}[label=lst:discretemetric_xml, caption={A wente torus given by a discrete metric. Vertices are given implictly
by following the order of triangle glueings.}, numbers=none, language=XML, captionpos=b]
<DiscreteMetric name="Wente Torus">
	<MetricEdge length="1.0" index="0"/>
	<MetricEdge length="1.0" index="1"/>
	<MetricEdge length="1.0" index="2"/>
	<MetricTriangle edge1="0" edge2="1" edge3="2"/>
	<MetricTriangle edge1="0" edge2="1" edge3="2"/>
</DiscreteMetric>
\end{lstlisting}

{\bf Data lists}

Each of the data nodes as described above can appear in an element of type {\tt
ConformalDataList}. A typical XML file representing the data of an example of
Chapter~\ref{chp:conformal_examples} contains input data, e.g. {\tt
SchottkyData} and {\tt DiscreteMetric}, as well as the resulting ouput
embedding and uniformization data represented as {\tt HalfedgeEmbedding} and
{\tt UniformizationData}.

\begin{lstlisting}[label=lst:datalist_xml, caption={A list of data XML nodes as the result of an algorithm calculating the Fuchsian uniformization of a genus $1$ Riemann surface given by Schottky data.}, numbers=none, language=XML, captionpos=b]
<ConformalDataList>
	<SchottkyData name="Schottky Data g1">
		...
	</SchottkyData>
	<DiscreteMetric name="Input Schottky Data Metric">
		...
	</DiscreteMetric>
	<HalfedgeEmbedding name="Output Euclidean Embedding">
		...
	</HalfedgeEmbedding>
	<HalfedgeMap name="Uniformizing Map">
		<Domain name="Uniformizing Map_domain">
			...
		</Domain>
		<Image name="Uniformizing Map_image">
			...
		</Image>
	</HalfedgeMap>
	<UniformizationData name="Direct Uniformization">
		...
	</UniformizationData>
	<UniformizationData name="Minimal Uniformization">
		...
	</UniformizationData>
</ConformalDataList>
\end{lstlisting}

\section{Uniformization and conformal mappings} \label{sec:conformallab_ui} The
user interface of {\sc ConformalLab} is devided into panels which serve
separate purposes in the workflow of performing experiments with discrete
Riemann surfaces and conformal mappings.


{\bf Data import and export}

\begin{figure}
\resizebox{\textwidth}{!}{
\includegraphics[width=0.5\linewidth]{conformllab/conformal_data.png}
\includegraphics[width=0.5\linewidth]{conformllab/hyperelliptic_curve.png}
\includegraphics[width=0.5\linewidth]{conformllab/schottky_modeller.png}
}
\caption{The data import and export interface (left).
Hyperelliptic curve interface (middle).
Schottky modeler user interface (right).}
\label{fig:data_interfaces}
\end{figure}

The data import and export panel, see Figure~\ref{fig:data_interfaces} left, provides
functions to import and export XML data as described in
Section~\ref{sec:conformal_data}.  Data files can be loaded into memory via the
Import button. A table lists the entries of the loaded file.  Loadable are {\tt
ConformalDataList} as well as single data instances. The entries of a {\tt
ConformalDataList} are listed in the table of the panel. 

Each of the rows
contains buttons to save the data to disk (blue disk), load it into the program
(gear with green arrow), or delete it from the list (red circle).  The function
of the load button depends on the data type. A {\tt HalfedgeEmbedding} is
loaded as geometry and is displayed in the 3D viewer. A {\tt HalfedgeMap}
defines geometry together with texture coordinates and boundary
identifications. If suitable boundary identification is given a uniformizing
group is calculated and visualized. {\tt HyperEllipticAlgebraicCurve}s are
loaded into the hyperelliptic curve panel of the user interface, see
Figure~\ref{fig:data_interfaces}, middle.  {\tt SchottkyData} is loaded into
the Schottky modeler panel, see Figure~\ref{fig:data_interfaces}, right.


{\bf Hyperelliptic curves}

The hyperelliptic curve panel (Figure~\ref{fig:data_interfaces} middle) is
used to create branched triangulations of the doubly covered sphere.
Hyperelliptic curves are defined vie their branch points, see
Section~\ref{sec:branched_coverings} of Chapter~\ref{chp:conformal_examples}.

In the hyperelliptic curve panel the user can add branch points by
double-clicking in the graph paper view.
Double-clicking an existing point brings up a coordinate editor. The lower
section of the panel defines parameters of the mesh creation. The user can
choose to add extra normally disctributed random points to the triangulation.
These points can be further optimized to form a more regular triangulation.
The number of point equalizer iterations defines the numer of gradient decent
steps in the optimization of the functional defined in
Section~\ref{sec:branched_coverings}.  The location of the branch points can be
normalized via a M{\"o}bius transformation on the sphere such that the
center of mass of the points is the center of the sphere. For the detains see also~
\ref{sec:branched_coverings}.

\begin{figure}
\centering
\includegraphics[width=0.45\linewidth]{conformllab/main_interface.png}
\caption{The main interface of {\sc ConformalLab}.}
\label{fig:conformal_main}
\end{figure}

{\bf Schottky modeler}

The Schottky modeler panel (See Figure~\ref{fig:data_interfaces} right) defines Schottky data for a Riemann surface, see Section~\ref{sec:schottky_examples}. 

In the graph-paper view the circles and
fix points of the generators are shown and can be modified. Moving a fix point
of a generator transforms the corresponding circle as the image of the
circle around the other fix point. Moving a circle causes the image circle to be recalculated. 
New generators can be added from the right-click menu. The parameter $\mu$ of
each generator can be edited in the table below.
Similar to the generation of hyperelliptic data additional points can be added and modified my
a regularization process. In addition to this the number of points that discretize the
circles can be given.

The "Generate Surface" button creates a triangulated surface together with
a metric calculated from the Schottky data. This surface can then be uniformized
via the main interface. The "Uniformize" button directly creates a uniformization and 
introduces cuts along the circles of the schottky data to. The corresponding fundamental
domain is then bounded by the preimages of the circles and curves connecting them.
Most of the examples of Section~\ref{sec:schottky_examples} use this fundamental domain.

{\bf Main interface}

The main interface of {\sc ConformalLab} offers all functions to create the conformal mapping  examples described in this work (see Figure~\ref{fig:conformal_main}). It is divided into sections that we cover briefly from top to bottom. 

The user interface comes in two modi, normal mode and expert mode, that can be switched with the "Expert Mode" check box. In normal mode we show only user interface elements that are needed by users of {\sc VaryLab} for surface parameterization and remeshing of discrete surfaces, see Chapter~\ref{chp:varylab}. All other elements are hidden in normal mode.

{\sc ConformalLab} uses two numerical libraries to implement energy minimization. They can be chosen from the drop-down box at the top of the panel. "Petsc/Tao Numerics" selects the {\sc PETSc/TAO} C++ library, see~\cite{petsc-web-page, tao-user-ref}. We use the Newton Trust Region method as implemented by {\sc PETSc/TAO} whenever we have calculated the Hessian metrix for the minimized energy. Otherwise we use the LMVM method with default configuration.

"Java/MTJ Numerics" implements a version of Newtons method using the linear algebra package
MTJ, see~\cite{mtj-website}.




\subfilebibliography
\end{document}

%%% Local Variables:
%%% TeX-master: "Thesis.tex"
%%% End:
